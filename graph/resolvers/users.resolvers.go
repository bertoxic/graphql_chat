package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"

	"github.com/bertoxic/graphqlChat/graph"
	"github.com/bertoxic/graphqlChat/graph/model"
	"github.com/bertoxic/graphqlChat/internal/models"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput, userID string) (*model.User, error) {
	newInput := models.UpdateUserInput{
		FullName:          input.FullName,
		UserName:          input.UserName,
		Email:             input.Email,
		Bio:               input.Bio,
		DateOfBirth:       input.DateOfBirth,
		ProfilePictureURL: input.ProfilePictureURL,
		CoverPictureURL:   input.CoverPictureURL,
		Location:          input.Location,
		Website:           input.Website,
		IsPrivate:         input.IsPrivate,
	}
	userdetails, err := r.UserService.UpdateUserDetails(ctx, newInput, userID)
	if err != nil {
		return nil, err
	}
	formattedDate := userdetails.DateOfBirth.Format("2006-01-02 15:04:05")
	newuserDetails := &model.User{
		ID:                userdetails.ID,
		Username:          userdetails.UserName,
		Email:             userdetails.Email,
		FullName:          userdetails.FullName,
		Bio:               userdetails.Bio,
		DateOfBirth:       &formattedDate,
		ProfilePictureURL: userdetails.ProfilePictureURL,
		CoverPictureURL:   userdetails.CoverPictureURL,
		Location:          userdetails.Location,
		Website:           userdetails.Website,
		IsPrivate:         userdetails.IsPrivate,
		UpdatedAt:         userdetails.UpdatedAt,
	}

	return newuserDetails, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	// Assuming we can get the current user's ID from the context
	currentUserID := getCurrentUserID(ctx)

	userResponse, err := r.UserService.FollowUser(ctx, currentUserID, userID)
	if err != nil {
		return nil, err
	}

	return &model.UserResponse{
		Success: true,
		Message: &userResponse.Message,
		Data:    nil,
	}, nil
}

// UnfollowUser is the resolver for the unfollowUser field.
func (r *mutationResolver) UnfollowUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	// Assuming we can get the current user's ID from the context
	currentUserID := getCurrentUserID(ctx)

	userResponse, err := r.UserService.UnfollowUser(ctx, currentUserID, userID)
	if err != nil {
		return nil, err
	}

	return &model.UserResponse{
		Success: userResponse.Success,
		Message: nil,
		Data:    nil,
	}, nil
}

// BlockUser is the resolver for the blockUser field.
func (r *mutationResolver) BlockUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	panic(fmt.Errorf("not implemented: BlockUser - blockUser"))
}

// UnblockUser is the resolver for the unblockUser field.
func (r *mutationResolver) UnblockUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	panic(fmt.Errorf("not implemented: UnblockUser - unblockUser"))
}

// MuteUser is the resolver for the muteUser field.
func (r *mutationResolver) MuteUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	panic(fmt.Errorf("not implemented: MuteUser - muteUser"))
}

// UnmuteUser is the resolver for the unmuteUser field.
func (r *mutationResolver) UnmuteUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	panic(fmt.Errorf("not implemented: UnmuteUser - unmuteUser"))
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error) {
	panic(fmt.Errorf("not implemented: ResetPassword - changePassword"))
}

// RequestPasswordReset is the resolver for the requestPasswordReset field.
func (r *mutationResolver) RequestPasswordReset(ctx context.Context, email string) (bool, error) {
	panic(fmt.Errorf("not implemented: RequestPasswordReset - requestPasswordReset"))
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, userID string, token string, newPassword string) (bool, error) {
	userResponse, err := r.UserService.ResetPassword(ctx, userID, token, newPassword)
	if err != nil {
		return userResponse.Success, err
	}
	return true, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, password string) (bool, error) {
	userResponse, err := r.UserService.DeleteUser(ctx, password)
	if err != nil {
		return false, err
	}
	return userResponse.Success, nil
}

// ReportUser is the resolver for the reportUser field.
func (r *mutationResolver) ReportUser(ctx context.Context, userID string, reason string) (bool, error) {
	panic(fmt.Errorf("not implemented: ReportUser - reportUser"))
}

// UpdateProfileColors is the resolver for the updateProfileColors field.
func (r *mutationResolver) UpdateProfileColors(ctx context.Context, primaryColor string, secondaryColor string) (*model.UserResponse, error) {
	panic(fmt.Errorf("not implemented: UpdateProfileColors - updateProfileColors"))
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	user, err := r.UserService.GetUserByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:       user.ID,
		Username: user.UserName,
		Email:    user.Email,
		// Add other fields as necessary
	}, nil
}

// GetUserByUsername is the resolver for the getUserByUsername field.
func (r *queryResolver) GetUserByUsername(ctx context.Context, username string) (*model.User, error) {
	user, err := r.UserService.GetUserByUsername(ctx, username)
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:       user.ID,
		Username: user.UserName,
		Email:    user.Email,
		// Add other fields as necessary
	}, nil
}

// GetCurrentUser is the resolver for the getCurrentUser field.
func (r *queryResolver) GetCurrentUser(ctx context.Context) (*model.User, error) {
	panic(fmt.Errorf("not implemented: GetCurrentUser - getCurrentUser"))
}

// GetUserFollowers is the resolver for the getUserFollowers field.
func (r *queryResolver) GetUserFollowers(ctx context.Context, userID string, limit *int, offset *int) ([]*model.User, error) {
	l := 10 // default limit
	o := 0  // default offset
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	followers, err := r.UserService.GetUsersFollowers(ctx, userID, l, o)
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, follower := range followers {
		result = append(result, &model.User{
			ID:       follower.ID,
			Username: follower.UserName,
			Email:    follower.Email,
			// Add other fields as necessary
		})
	}

	return result, nil
}

// GetUserFollowing is the resolver for the getUserFollowing field.
func (r *queryResolver) GetUserFollowing(ctx context.Context, userID string, limit *int, offset *int) ([]*model.User, error) {
	l := 10 // default limit
	o := 0  // default offset
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	following, err := r.UserService.GetUsersFollowing(ctx, userID, l, o)
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, followedUser := range following {
		result = append(result, &model.User{
			ID:       followedUser.ID,
			Username: followedUser.UserName,
			Email:    followedUser.Email,
			// Add other fields as necessary
		})
	}

	return result, nil
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query string, limit *int) ([]*model.User, error) {
	l := 10 // default limit
	if limit != nil {
		l = *limit
	}

	users, err := r.UserService.SearchUsers(ctx, query, l)
	if err != nil {
		return nil, fmt.Errorf("failed to search users: %w", err)
	}

	if len(users) == 0 {
		return []*model.User{}, nil
	}

	result := make([]*model.User, 0, len(users))

	for _, user := range users {
		if user == nil {
			continue
		}

		var formattedDOB *string
		if user.DateOfBirth != nil {
			formatted := user.DateOfBirth.Format("2006-01-02 15:04:05")
			formattedDOB = &formatted
		}

		result = append(result, &model.User{
			ID:                user.ID,
			Username:          user.UserName,
			Email:             user.Email,
			FullName:          user.FullName,
			Bio:               user.Bio,
			DateOfBirth:       formattedDOB,
			ProfilePictureURL: user.ProfilePictureURL,
			CoverPictureURL:   user.CoverPictureURL,
			Location:          user.Location,
			Website:           user.Website,
			IsPrivate:         user.IsPrivate,
			CreatedAt:         user.CreatedAt,
			UpdatedAt:         user.UpdatedAt,
		})
	}

	return result, nil
}

// GetUserDetails is the resolver for the getUserDetails field.
func (r *queryResolver) GetUserDetails(ctx context.Context, userID string) (*model.UserDetails, error) {
	panic(fmt.Errorf("not implemented: GetUserDetails - getUserDetails"))
}

// GetUserStats is the resolver for the getUserStats field.
func (r *queryResolver) GetUserStats(ctx context.Context, userID string) (*model.UserStats, error) {
	stats, err := r.UserService.GetUserStats(ctx, userID)
	if err != nil {
		return nil, err
	}

	return &model.UserStats{
		TotalPosts:     stats.TotalPosts,
		TotalFollowers: stats.TotalFollowers,
		TotalFollowing: stats.TotalFollowing,
	}, nil
}

// SearchAll is the resolver for the searchAll field.
func (r *queryResolver) SearchAll(ctx context.Context, query string, limit *int) (*model.SearchResult, error) {
	panic(fmt.Errorf("not implemented: SearchAll - searchAll"))
}

// GetSuggestedUsers is the resolver for the getSuggestedUsers field.
func (r *queryResolver) GetSuggestedUsers(ctx context.Context, limit *int) ([]*model.User, error) {
	l := 10 // default limit
	if limit != nil {
		l = *limit
	}

	currentUserID := getCurrentUserID(ctx)
	users, err := r.UserService.GetSuggestedUsers(ctx, currentUserID, l)
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, user := range users {
		result = append(result, &model.User{
			ID:       user.ID,
			Username: user.UserName,
			Email:    user.Email,
			// Add other fields as necessary
		})
	}

	return result, nil
}

// GetUserLikedPosts is the resolver for the getUserLikedPosts field.
func (r *queryResolver) GetUserLikedPosts(ctx context.Context, userID string, limit *int, offset *int) ([]*model.Post, error) {
	panic(fmt.Errorf("not implemented: GetUserLikedPosts - getUserLikedPosts"))
}

// CheckUsernameAvailability is the resolver for the checkUsernameAvailability field.
func (r *queryResolver) CheckUsernameAvailability(ctx context.Context, username string) (bool, error) {
	// Assuming we have a CheckUsernameAvailability method in UserService
	isAvailable, err := r.UserService.CheckUsernameAvailability(ctx, username)
	if err != nil {
		return false, err
	}
	return isAvailable, nil
}

// UserStatusChanged is the resolver for the userStatusChanged field.
func (r *subscriptionResolver) UserStatusChanged(ctx context.Context, userID string) (<-chan *model.User, error) {
	//TODO implement me
	panic("implement me")
}

// Subscription returns graph.SubscriptionResolver implementation.
func (r *Resolver) Subscription() graph.SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
